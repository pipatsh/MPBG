//
//  MobileListInteractorTests.swift
//  MPBG
//
//  Created by Pipat Shuleepongchad on 5/7/2562 BE.
//  Copyright (c) 2562 Pipat Shuleepongchad. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import MPBG
import XCTest

class MobileListInteractorTests: XCTestCase
{
  // MARK: Subject under test
  
  var sut: MobileListInteractor!
  
  // MARK: Test lifecycle
  
  override func setUp()
  {
    super.setUp()
    setupMobileListInteractor()
  }
  
  override func tearDown()
  {
    super.tearDown()
  }
  
  // MARK: Test setup
  
  func setupMobileListInteractor()
  {
    sut = MobileListInteractor()
  }
  
  // MARK: Test doubles
  
  class MobileListPresentationLogicSpy: MobileListPresentationLogic
  {
    var presentFetchedMobilesCalled = false
    
    func presentFetchedMobiles(response: MobileList.FetchMobiles.Response)
    {
      presentFetchedMobilesCalled = true
    }
    
    var presentAddFavouriteMobileCalled = false
    
    func presentAddFavouriteMobile(response: MobileList.AddFavourite.Response)
    {
      presentAddFavouriteMobileCalled = true
    }
    
    var presentDeleteFavouriteMobileCalled = false
    
    func presentDeleteFavouriteMobile(response: MobileList.DeleteFavourite.Response)
    {
      presentDeleteFavouriteMobileCalled = true
    }
    
    var presentFetchedMobilesErrorCalled = false
    
    func presentFetchedMobilesError(response: MobileList.Error.Response)
    {
      presentFetchedMobilesErrorCalled = true
    }
    
    var presentErrorCalled = false
    
    func presentError(response: MobileList.Error.Response)
    {
      presentErrorCalled = true
    }
    
    var presentProgressCalled = false
    
    func presentProgress(response: MobileList.Progress.Response)
    {
      presentProgressCalled = true
    }
  }
  
  class MobilesWorkerSuccessSpy: MobilesWorker
  {
    var fetchMobilesCalled = false
    
    override func fetchMobiles(completionHandler: @escaping ([Mobile]?, DataError?) -> Void)
    {
      fetchMobilesCalled = true
      completionHandler([Seeds.MobileModel.motoG5], nil)
    }
    
    var fetchFavoriteMobilesCalled = false
    
    override func fetchFavoriteMobiles(completionHandler: @escaping ([Mobile]?, DataError?) -> Void)
    {
      fetchFavoriteMobilesCalled = true
      completionHandler([], nil)
    }
    
    var addFavouriteMobileCalled = false
    
    override func addFavouriteMobile(mobile: Mobile, completionHandler: @escaping (Mobile?, DataError?) -> Void)
    {
      addFavouriteMobileCalled = true
      completionHandler(Seeds.MobileModel.motoG5, nil)
    }
    
    var deleteFavouriteMobileCalled = false
    
    override func deleteFavouriteMobile(id: Int, completionHandler: @escaping (Mobile?, DataError?) -> Void)
    {
      deleteFavouriteMobileCalled = true
      completionHandler(Seeds.MobileModel.motoG5, nil)
    }

  }
  
  class MobilesWorkerFailSpy: MobilesWorker
  {
    var fetchMobilesCalled = false
    
    override func fetchMobiles(completionHandler: @escaping ([Mobile]?, DataError?) -> Void)
    {
      fetchMobilesCalled = true
      completionHandler(nil, DataError.cannotFetch("Fetch mobiles failed"))
    }
    
    var fetchFavoriteMobilesCalled = false
    
    override func fetchFavoriteMobiles(completionHandler: @escaping ([Mobile]?, DataError?) -> Void)
    {
      fetchFavoriteMobilesCalled = true
      completionHandler(nil, DataError.cannotFetch("Fetch mobiles failed"))
    }
    
    var addFavouriteMobileCalled = false
    
    override func addFavouriteMobile(mobile: Mobile, completionHandler: @escaping (Mobile?, DataError?) -> Void)
    {
      addFavouriteMobileCalled = true
      completionHandler(nil, DataError.cannotAdd("Add mobile failed with id: \(mobile.id)"))
    }
    
    var deleteFavouriteMobileCalled = false
    
    override func deleteFavouriteMobile(id: Int, completionHandler: @escaping (Mobile?, DataError?) -> Void)
    {
      deleteFavouriteMobileCalled = true
      completionHandler(nil, DataError.cannotDelete("Delete mobile failed with id: \(id)"))
    }
    
  }
  
  // MARK: Tests
  
  func testFetchMobilesShouldAskMobilesWorkerToFetchFavouriteAndFetchMobilesAndPresenterToFetchedMobiles()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let workerAPISpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesAPI())
    sut.workerAPI = workerAPISpy
    let request = MobileList.FetchMobiles.Request(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh))
    
    sut.fetchMobiles(request: request)
    
    XCTAssert(workerCoreDataSpy.fetchFavoriteMobilesCalled, "FetchMobiles() should ask MobilesWorker to favourite mobiles")
    XCTAssert(workerAPISpy.fetchMobilesCalled, "FetchMobiles() should ask MobilesWorker to fetch mobiles")
    
    XCTAssert(spy.presentFetchedMobilesCalled, "FetchMobile() should ask presenter to fetched mobiles")
  }
  
  func testFetchMobilesShouldAskMobilesWorkerToFetchMobilesAndPresenterToFetchedMobilesWhenFavouriteMobilesExist()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let workerAPISpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesAPI())
    sut.workerAPI = workerAPISpy
    sut.favouriteMobiles = []
    let request = MobileList.FetchMobiles.Request(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh))
    
    sut.fetchMobiles(request: request)
    
    XCTAssert(!workerCoreDataSpy.fetchFavoriteMobilesCalled, "FetchMobiles() should not ask MobilesWorker to fetch favourite mobiles")
    XCTAssert(workerAPISpy.fetchMobilesCalled, "FetchMobiles() should ask MobilesWorker to fetch mobiles")
    
    XCTAssert(spy.presentFetchedMobilesCalled, "FetchMobile() should ask presenter to fetched mobiles")
  }
  
  func testFetchMobilesShouldPresenterToFetchedMobilesWhenMobilesAndFavouriteMobilesExist()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let workerAPISpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesAPI())
    sut.workerAPI = workerAPISpy
    sut.mobiles = [Seeds.MobileModel.motoG5]
    sut.favouriteMobiles = []
    let request = MobileList.FetchMobiles.Request(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh))
    
    sut.fetchMobiles(request: request)
    
    XCTAssert(!workerCoreDataSpy.fetchFavoriteMobilesCalled, "FetchMobiles() should not ask MobilesWorker to fetch favourite mobiles")
    XCTAssert(!workerAPISpy.fetchMobilesCalled, "FetchMobiles() should not ask MobilesWorker to fetch mobiles")
    
    XCTAssert(spy.presentFetchedMobilesCalled, "FetchMobile() should ask presenter to fetched mobiles")
  }
  
  func testFetchMobilesShouldPresenterToErrorWhenMobilesWorkReturnErrorOnFetchedFavouriteMobiles()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerFailSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let request = MobileList.FetchMobiles.Request()
    
    sut.fetchMobiles(request: request)
    
    XCTAssert(workerCoreDataSpy.fetchFavoriteMobilesCalled, "FetchMobiles() should ask MobilesWorker to fetch mobiles")
    XCTAssert(spy.presentErrorCalled, "FetchMobiles() should ask presenter to error")
  }
  
  func testFetchMobilesShouldPresenterToMobilesErrorWhenMobilesWorkReturnErrorOnFetchedMobiles()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let workerAPISpy = MobilesWorkerFailSpy(mobilesStore: MobilesAPI())
    sut.workerAPI = workerAPISpy
    let request = MobileList.FetchMobiles.Request()
    
    sut.fetchMobiles(request: request)
    
    XCTAssert(workerCoreDataSpy.fetchFavoriteMobilesCalled, "FetchMobiles() should ask MobilesWorker to fetch mobiles")
    XCTAssert(workerAPISpy.fetchMobilesCalled, "FetchMobiles() should ask MobilesWorker to fetch mobiles")
    
    XCTAssert(spy.presentFetchedMobilesErrorCalled, "FetchMobiles() should ask presenter to mobiles error")
  }
  
  
  func testAddFavourtieMobileShouldAskMobilesWorkerToAddFavourtieMobileAndPresenterToAddFavourtie()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let workerAPISpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesAPI())
    sut.workerAPI = workerAPISpy
    sut.mobiles = [Seeds.MobileModel.motoG5]

    let request = MobileList.AddFavourite.Request(id: 1)
    sut.addFavoriteMobile(request: request)
    
    XCTAssert(spy.presentAddFavouriteMobileCalled, "AddFavouriteMobile() should ask presenter to add favourite")
  }
  
  func testAddFavourtieMobileShouldPresenterToErrorWhenIdNotExist()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy

    let request = MobileList.AddFavourite.Request(id: 1)
    sut.addFavoriteMobile(request: request)
    
    XCTAssert(spy.presentErrorCalled, "AddFavouriteMobile() should ask presenter to error when id not exist")
  }
  
  func testAddFavourtieMobileShouldPresenterToErrorWhenWorkerReturnError()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerFailSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    sut.mobiles = [Seeds.MobileModel.motoG5]

    let request = MobileList.AddFavourite.Request(id: 1)
    sut.addFavoriteMobile(request: request)
    
    XCTAssert(spy.presentErrorCalled, "AddFavouriteMobile() should ask presenter to error when worker return error")
  }
  
  func testDeleteFavourtieMobileShouldAskMobilesWorkerToDeleteFavourtieMobileAndPresenterToDeleteFavourtie()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    let workerAPISpy = MobilesWorkerSuccessSpy(mobilesStore: MobilesAPI())
    sut.workerAPI = workerAPISpy
    sut.mobiles = [Seeds.MobileModel.motoG5]
    
    let request = MobileList.DeleteFavourite.Request(id: 1)
    sut.deleteFavoriteMobile(request: request)
    
    XCTAssert(spy.presentDeleteFavouriteMobileCalled, "DeleteFavouriteMobile() should ask presenter to add favourite")
  }
  
  func testDeleteFavourtieMobileShouldPresenterToErrorWhenWorkerReturnError()
  {
    let spy = MobileListPresentationLogicSpy()
    sut.presenter = spy
    let workerCoreDataSpy = MobilesWorkerFailSpy(mobilesStore: MobilesCoreDataStore())
    sut.workerCoreData = workerCoreDataSpy
    sut.mobiles = [Seeds.MobileModel.motoG5]
    
    let request = MobileList.DeleteFavourite.Request(id: 1)
    sut.deleteFavoriteMobile(request: request)
    
    XCTAssert(spy.presentErrorCalled, "DeleteFavouriteMobile() should ask presenter to error when worker return error")
  }

}

