//
//  MobileListViewControllerTests.swift
//  MPBG
//
//  Created by Pipat Shuleepongchad on 5/7/2562 BE.
//  Copyright (c) 2562 Pipat Shuleepongchad. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import MPBG
import XCTest

class MobileListViewControllerTests: XCTestCase
{
  // MARK: Subject under test
  
  var sut: MobileListViewController!
  var window: UIWindow!
  
  // MARK: Test lifecycle
  
  override func setUp()
  {
    super.setUp()
    window = UIWindow()
    setupMobileListViewController()
  }
  
  override func tearDown()
  {
    window = nil
    super.tearDown()
  }
  
  // MARK: Test setup
  
  func setupMobileListViewController()
  {
    let bundle = Bundle.main
    let storyboard = UIStoryboard(name: "Main", bundle: bundle)
    sut = storyboard.instantiateViewController(withIdentifier: "MobileListViewController") as? MobileListViewController
  }
  
  func loadView()
  {
    window.addSubview(sut.view)
    RunLoop.current.run(until: Date())
  }
  
  // MARK: Test doubles
  
  class MobileListBusinessLogicSpy: MobileListBusinessLogic
  {
    var displayMethods = [
      DisplayMethod(type: .all),
      DisplayMethod(type: .favourite)
    ]
    
    var sortMethods = [
      SortMethod(type: .priceLowToHigh),
      SortMethod(type: .priceHighToLow),
      SortMethod(type: .rating)
    ]
    
    var fetchMobilesCalled = false
    
    func fetchMobiles(request: MobileList.FetchMobiles.Request) {
      fetchMobilesCalled = true
    }
    
    var addFavoriteMobileCalled = false
    
    func addFavoriteMobile(request: MobileList.AddFavourite.Request) {
      addFavoriteMobileCalled = true
    }
    
    var deleteFavoriteMobileCalled = false
    
    func deleteFavoriteMobile(request: MobileList.DeleteFavourite.Request) {
      deleteFavoriteMobileCalled = true
    }
  }
  
  class TableViewSpy: UITableView
  {
    var reloadDataCalled = false
    
    override func reloadData()
    {
      reloadDataCalled = true
    }
  }
  
  // MARK: Tests
  
  func testShouldFetchMobileWhenViewIsLoaded() {
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    XCTAssertTrue(spy.fetchMobilesCalled, "viewDidLoad() should ask the interactor to fetch mobiles")
  }
  
  func testShouldAddFavouriteMobileWhenCallAddFavouriteMobile() {
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy

    loadView()
    sut.addFavouriteMobile(id: 1)
    XCTAssertTrue(spy.addFavoriteMobileCalled, "addFavouriteMobile(id:) should ask the interactor to add mobile")
  }

  func testShouldFavouriteMobileWhenCallDeleteFavouriteMobile() {
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy

    loadView()
    sut.deleteFavouriteMobile(id: 1)
    XCTAssertTrue(spy.deleteFavoriteMobileCalled, "addFavouriteMobile(id:) should ask the interactor to add mobile")
  }
  
  func testShouldDisplayFetchedMobiles() {
    let tableViewSpy = TableViewSpy()
    
    sut.tableView = tableViewSpy
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.displayFetchedMobiles(viewModel: viewModel)
    
    // Then
    XCTAssert(tableViewSpy.reloadDataCalled, "Displaying fetched mobiles should reload the table view")
  }
  
  func testShouldDisplayAddFavoriteMobile() {
    let tableViewSpy = TableViewSpy()
    
    sut.tableView = tableViewSpy
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let fetchMobilesViewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = fetchMobilesViewModel
    
    let viewModel = MobileList.AddFavourite.ViewModel(id: 1)
    sut.displayAddFavouriteMobile(viewModel: viewModel)

    XCTAssertEqual(sut.fetchMobilesViewModel!.displayedMobiles[0].isFavourite, true, "isFavourite should be true")
  }
  
  func testShouldDisplayDeleteFavoriteMobileWhenDisplayMethodTypeIsAll() {
    let tableViewSpy = TableViewSpy()
    
    sut.tableView = tableViewSpy
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let fetchMobilesViewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = fetchMobilesViewModel
    let viewModel = MobileList.DeleteFavourite.ViewModel(displayMethod: DisplayMethod(type: .all), id: 1)
    sut.displayDeleteFavouriteMobile(viewModel: viewModel)

    XCTAssertEqual(sut.fetchMobilesViewModel!.displayedMobiles[0].isFavourite, false, "isFavourite should is true")
  }
  
  func testShouldDisplayDeleteFavoriteMobileWhenDisplayMethodTypeIsFavourite() {
    let tableViewSpy = TableViewSpy()
    
    sut.tableView = tableViewSpy
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let fetchMobilesViewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = fetchMobilesViewModel
    let viewModel = MobileList.DeleteFavourite.ViewModel(displayMethod: DisplayMethod(type: .favourite), id: 1)
    sut.displayDeleteFavouriteMobile(viewModel: viewModel)
    XCTAssertFalse(sut.fetchMobilesViewModel!.displayedMobiles.contains(where: { $0.id == 1}), "displayedMobiles should not contain mobile id : 1")
  }
  
  func testShouldDisplayMobilesError() {
    let viewModel = MobileList.Error.ViewModel(title: "Can not fetch", message: "fetch failed")
    sut.displayMobilesError(viewModel: viewModel)
    
    XCTAssertEqual(sut.alertController!.title, "Can not fetch", "title should be \"Can not fetch\"")
    XCTAssertEqual(sut.alertController!.message, "fetch failed", "title should be \"fetch failed\"")
  }
  
  func testShouldDisplayError() {
    let viewModel = MobileList.Error.ViewModel(title: "Can not fetch", message: "fetch failed")
    sut.displayError(viewModel: viewModel)
    
    XCTAssertEqual(sut.alertController!.title, "Can not fetch", "title should be \"Can not fetch\"")
    XCTAssertEqual(sut.alertController!.message, "fetch failed", "title should be \"fetch failed\"")
  }
  
  func testShouldDisplayProgressShow() {
    let viewModel = MobileList.Progress.ViewModel(show: true)
    sut.displayProgress(viewModel: viewModel)
    
    XCTAssertEqual(sut.displayProgress, true, "progress should be show")
  }
  
  func testShouldDisplayProgressHidden() {
    let viewModel = MobileList.Progress.ViewModel(show: false)
    sut.displayProgress(viewModel: viewModel)
    
    XCTAssertEqual(sut.displayProgress, false, "progress should be show")
  }
  
  func testNumberOfRowsInSectionInTableViewShouldEqaulNumberOfMobilesToDisplay() {
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    
    let tableView = sut.tableView
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel

    let numberOfRows = sut.tableView(tableView!, numberOfRowsInSection: 0)
    XCTAssertEqual(numberOfRows, viewModel.displayedMobiles.count, "The number of table view rows should equal the number of mobiles to display")
  }
  
  func testShouldConfigureTableViewCellToDisplayMobiles()
  {
    // Given
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    
    let tableView = sut.tableView
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel
    
    viewModel.displayedMobiles.enumerated().forEach { (index, displayedMobile) in
      let indexPath = IndexPath(row: index, section: 0)
      let cell = sut.tableView(tableView!, cellForRowAt: indexPath) as! MobileListTableViewCell
      cell.display(displayedMobile, displayMethod: viewModel.displayMethod)
      XCTAssertEqual(cell.nameLabel.text, displayedMobile.name, "nameLabel should equal to \(displayedMobile.name)")
      XCTAssertEqual(cell.descriptionLabel.text, displayedMobile.description, "descriptionLabel should equal to \(displayedMobile.description)")
      XCTAssertEqual(cell.priceLabel.text, "Price: \(displayedMobile.price)", "priceLabel should equal to Price: \(displayedMobile.price)")
      XCTAssertEqual(cell.ratingLabel.text, "Rating: \(displayedMobile.rating)", "ratingLabel should equal to Rating: \(displayedMobile.rating)")
      XCTAssertEqual(cell.favouriteButton.isSelected, displayedMobile.isFavourite, "favouriteButton.selected should be equal to \(displayedMobile.isFavourite)")
      
      let mothodType = viewModel.displayMethod.type
      XCTAssertEqual(cell.favouriteButton.isHidden, mothodType == .favourite, "favouriteButton.isHidden should equal to \(mothodType == .favourite)")
    }
  }
  
  func testShouldCanEditRowWhenDisplayMethodTypeIsAll() {
    // Given
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()

    let tableView = sut.tableView

    let displayedMobiles = [Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel
    
    displayedMobiles.enumerated().forEach { (index, displayedMobile) in
      let canEdit = sut.tableView(tableView!, canEditRowAt: IndexPath(row: index, section: 0))
      XCTAssertFalse(canEdit, "tableView should not be can edit row")
    }
  }
  
  func testShouldCanEditRowWhenDisplayMethodTypeIsFavourite() {
    // Given
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    
    let tableView = sut.tableView
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .favourite), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel
    
    displayedMobiles.enumerated().forEach { (index, displayedMobile) in
      let canEdit = sut.tableView(tableView!, canEditRowAt: IndexPath(row: index, section: 0))
      XCTAssertTrue(canEdit, "tableView should be can edit row")
    }
  }
  
  func testShouldDeteleFavourtieMobileWhenCommitEditStyleToDelete() {
    // Given
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    
    let tableView = sut.tableView
    
    let displayedMobiles = [Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .favourite), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel
    
    sut.tableView(tableView!, commit: .delete, forRowAt: IndexPath(row: 0, section: 0))
    XCTAssertTrue(spy.deleteFavoriteMobileCalled, "deleteFavouriteMobile(id:) should ask the interactor to delete mobile")
  }
  
  func testShouldAddFavouriteMobileWhenFavouriteButtonClicked()
  {
    // Given
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    
    let tableView = sut.tableView
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel
    
    let indexPath = IndexPath(row: 0, section: 0)
    let cell = sut.tableView(tableView!, cellForRowAt: indexPath) as! MobileListTableViewCell
    cell.favouriteButtonClicked(UIButton(frame: .zero))
    
    XCTAssertTrue(spy.addFavoriteMobileCalled, "addFavouriteMobile(id:) should ask the interactor to add mobile")
  }
  
  func testShouldDeleteFavouriteMobileWhenFavouriteButtonClicked()
  {
    // Given
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    
    loadView()
    
    let tableView = sut.tableView
    
    let displayedMobiles = [Seeds.MobileListDisplay.motoG5, Seeds.MobileListDisplay.sonyL1]
    let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: DisplayMethod(type: .all), sortMethod: SortMethod(type: .priceLowToHigh), displayedMobiles: displayedMobiles)
    sut.fetchMobilesViewModel = viewModel
    
    let indexPath = IndexPath(row: 1, section: 0)
    let cell = sut.tableView(tableView!, cellForRowAt: indexPath) as! MobileListTableViewCell
    cell.favouriteButtonClicked(UIButton(frame: .zero))
    
    XCTAssertTrue(spy.deleteFavoriteMobileCalled, "deleteFavouriteMobile(id:) should ask the interactor to delete mobile")
  }
  
  func testShouldFetchMobileWhenSegmentButtonClicked() {
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    let segmentedControlSpy = UISegmentedControl(items: ["All", "Favourite"])
    segmentedControlSpy.selectedSegmentIndex = 0
    sut.segmentedControl = segmentedControlSpy
    sut.segmentedControlClicked(sut.segmentedControl)
    XCTAssertTrue(spy.fetchMobilesCalled, "segmentedControlClicked(sender:) should ask the interactor to fetch mobiles")
  }
  
  func testShouldAlertControllerWhenSortButtonClicked() {
    let spy = MobileListBusinessLogicSpy()
    sut.interactor = spy
    sut.sortButtonClicked(UIBarButtonItem(title: "Sort", style: .plain, target: nil, action: nil))
    let alertController = sut.alertController!
    for index in 0...2 {
      let action = alertController.actions[index]
      let title = spy.sortMethods[index].stringValue
      XCTAssertEqual(action.title, title, "title should be \(title)")
    }
    let action = alertController.actions[3]
    XCTAssertEqual(action.title, "Cancel", "title should be Cancel")
  }

}
