//
//  MobileListPresenter.swift
//  MPBG
//
//  Created by Pipat Shuleepongchad on 2/7/2562 BE.
//  Copyright (c) 2562 Pipat Shuleepongchad. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MobileListPresentationLogic
{
  func presentFetchedMobiles(response: MobileList.FetchMobiles.Response)
  func presentAddFavouriteMobile(response: MobileList.AddFavourite.Response)
  func presentDeleteFavouriteMobile(response: MobileList.DeleteFavourite.Response)
  func presentFetchedMobilesError(response: MobileList.Error.Response)
  func presentError(response: MobileList.Error.Response)
  func presentProgress(response: MobileList.Progress.Response)
}

class MobileListPresenter: MobileListPresentationLogic
{
  weak var viewController: MobileListDisplayLogic?
  
  // MARK: Present Mobiles
  
  func presentFetchedMobiles(response: MobileList.FetchMobiles.Response)
  {
    if response.displayMethod.type == .all {
      let mobiles = sort(mobiles: response.mobiles, method: response.sortMethod)
      let displayedMobiles = mobiles.map {
        MobileList.DisplayedMobile(id: $0.id, name: $0.name, description: $0.description, thumbImageURL: $0.thumbImageURL, price: "$\($0.price)", rating: "\($0.rating)", isFavourite: response.favouriteMobiles.contains($0))
      }
      let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: response.displayMethod, sortMethod: response.sortMethod, displayedMobiles: displayedMobiles)
      viewController?.displayFetchedMobiles(viewModel: viewModel)
    } else {
      let mobiles = sort(mobiles: response.favouriteMobiles, method: response.sortMethod)
      let displayedMobiles = mobiles.map {
        MobileList.DisplayedMobile(id: $0.id, name: $0.name, description: $0.description, thumbImageURL: $0.thumbImageURL, price: "$\($0.price)", rating: "\($0.rating)", isFavourite: true)
      }
      let viewModel = MobileList.FetchMobiles.ViewModel(displayMethod: response.displayMethod, sortMethod: response.sortMethod, displayedMobiles: displayedMobiles)
      viewController?.displayFetchedMobiles(viewModel: viewModel)
    }
  }
  
  func presentAddFavouriteMobile(response: MobileList.AddFavourite.Response)
  {
    let viewModel = MobileList.AddFavourite.ViewModel(id: response.mobile.id)
    viewController?.displayAddFavouriteMobile(viewModel: viewModel)
  }
  
  func presentDeleteFavouriteMobile(response: MobileList.DeleteFavourite.Response)
  {
    let viewModel = MobileList.DeleteFavourite.ViewModel(displayMethod: response.displayMethod, id: response.mobile.id)
    viewController?.displayDeleteFavouriteMobile(viewModel: viewModel)
  }
  
  func presentFetchedMobilesError(response: MobileList.Error.Response)
  {
    let viewModel = MobileList.Error.ViewModel(title: response.error.reason, message: response.error.localizedDescription)
    self.viewController?.displayMobilesError(viewModel: viewModel)
  }
  
  func presentError(response: MobileList.Error.Response)
  {
    let viewModel = MobileList.Error.ViewModel(title: response.error.reason, message: response.error.localizedDescription)
    self.viewController?.displayError(viewModel: viewModel)
  }
  
  func presentProgress(response: MobileList.Progress.Response)
  {
    let viewModel = MobileList.Progress.ViewModel(show: response.show)
    viewController?.displayProgress(viewModel: viewModel)
  }
  
  private func sort(mobiles: [Mobile], method: SortMethod) -> [Mobile]
  {
    let sortedMobiles: [Mobile]
    switch method.type {
    case .priceLowToHigh:
      sortedMobiles = mobiles.sorted { $0.price < $1.price }
    case .priceHighToLow:
      sortedMobiles = mobiles.sorted { $0.price > $1.price }
    case .rating:
      sortedMobiles = mobiles.sorted { $0.rating > $1.rating }
    }
    return sortedMobiles
  }
}
